package com.purno.jobman;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import javax.sql.DataSource;
import java.sql.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class SqlJobStore implements JobStore {
    private final DataSource dataSource;
    private final ObjectMapper objectMapper;

    private boolean isTableCreated = false;

    public SqlJobStore(DataSource dataSource) {
        this.dataSource = dataSource;
        this.objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());
    }

    private void createTable() {
        if (isTableCreated) {
            return;
        }

        try (Connection conn = dataSource.getConnection()) {
            DatabaseMetaData metaData = conn.getMetaData();
            String databaseName = metaData.getDatabaseProductName().toLowerCase();

            // Determine database-specific syntax
            String idColumnDefinition = "BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY";
            if (databaseName.contains("mysql") || databaseName.contains("mariadb")) {
                idColumnDefinition = "BIGINT AUTO_INCREMENT PRIMARY KEY";
            }

            String sql = String.format(
                    "CREATE TABLE IF NOT EXISTS jobs (" +
                            "id %s, " +
                            "name VARCHAR(255), " +
                            "state VARCHAR(50), " +
                            "scheduled_time TIMESTAMP NULL, " +
                            "implementation_class VARCHAR(500) NOT NULL, " +
                            "job_json TEXT NOT NULL" +
                            ")", idColumnDefinition);

            try (Statement stmt = conn.createStatement()) {
                stmt.execute(sql);
                isTableCreated = true;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Could not create jobs table", e);
        }
    }

    @Override
    public void save(Job<?> job) {
        createTable();

        if (job.getId() <= 0) {
            insert(job);
        } else {
            update(job);
        }
    }

    private void insert(Job<?> job) {
        String sql = "INSERT INTO jobs (name, state, scheduled_time, implementation_class, job_json) VALUES (?, ?, ?, ?, ?)";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            prepareParams(ps, job);
            ps.executeUpdate();

            // Retrieve id
            try (ResultSet generatedKeys = ps.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    job.setId(generatedKeys.getLong(1));
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Error inserting job", e);
        }
    }

    private void update(Job<?> job) {
        String sql = "UPDATE jobs SET name= ?, state= ?, scheduled_time= ?, implementation_class= ?, job_json= ? WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            prepareParams(ps, job);
            ps.setLong(6, job.getId());
            ps.executeUpdate();
        } catch (Exception e) {
            throw new RuntimeException("Error updating job " + job.getId(), e);
        }
    }

    private void prepareParams(PreparedStatement ps, Job<?> job) throws Exception {
        ps.setString(1, job.getName());
        ps.setString(2, job.getState() != null ? job.getState().name() : null);
        ps.setTimestamp(3, job.getScheduledTime() != null ? Timestamp.from(job.getScheduledTime()) : null);
        ps.setString(4, job.getClass().getName());
        ps.setString(5, objectMapper.writeValueAsString(job));
    }

    @Override
    public Job<?> get(long jobId) {
        createTable();

        String sql = "SELECT implementation_class, job_json FROM jobs WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setLong(1, jobId);
            try (ResultSet rs = ps.executeQuery()) {
                List<Job<?>> jobs = deserializeJobs(rs);
                if (!jobs.isEmpty()) {
                    return jobs.getFirst();
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Error retrieving job " + jobId, e);
        }

        return null;
    }

    @Override
    public List<Job<?>> getAll() {
        createTable();

        String sql = "SELECT implementation_class, job_json FROM jobs ORDER BY id";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            try (ResultSet rs = ps.executeQuery()) {
                return deserializeJobs(rs);
            }
        } catch (Exception e) {
            throw new RuntimeException("Error listing jobs", e);
        }
    }

    @Override
    public List<Job<?>> getForRunningNow() {
        createTable();

        String sql = "SELECT implementation_class, job_json FROM jobs WHERE state = ? AND (scheduled_time IS NULL OR scheduled_time <= ?) ORDER BY id";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, JobState.INIT.name());
            ps.setTimestamp(2, Timestamp.from(Instant.now()));
            try (ResultSet rs = ps.executeQuery()) {
                return deserializeJobs(rs);
            }
        } catch (Exception e) {
            throw new RuntimeException("Error listing jobs", e);
        }
    }

    @Override
    public void delete(long jobId) {
        createTable();

        String sql = "DELETE FROM jobs WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setLong(1, jobId);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw new RuntimeException("Error deleting job " + jobId, e);
        }
    }

    @Override
    public long count() {
        createTable();

        String sql = "SELECT COUNT(*) FROM jobs";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return rs.getLong(1);
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Error counting jobs", e);
        }

        return 0;
    }

    private List<Job<?>> deserializeJobs(ResultSet resultSet) throws Exception {
        List<Job<?>> jobs = new ArrayList<>();

        while (resultSet.next()) {
            Class<?> clazz = Class.forName(resultSet.getString("implementation_class"));
            Job<?> job = (Job<?>) objectMapper.readValue(resultSet.getString("job_json"), clazz);
            job.setId(resultSet.getLong("id"));
            jobs.add(job);
        }

        return jobs;
    }
}